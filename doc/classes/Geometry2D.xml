<?xml version="1.0" encoding="UTF-8" ?>
<class name="Geometry2D" inherits="Object" version="4.1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../class.xsd">
	<brief_description>
		Helper node to calculate generic geometry operations in 2D space.
	</brief_description>
	<description>
		Geometry2D provides users with a set of helper functions to create geometric shapes, compute intersections between shapes, and process various other geometric operations.
	</description>
	<tutorials>
	</tutorials>
	<methods>
		<method name="clip_polygons">
			<return type="PackedVector2Array[]" />
			<param index="0" name="polygon_a" type="PackedVector2Array" />
			<param index="1" name="polygon_b" type="PackedVector2Array" />
			<description>
				Clips [param polygon_a] against [param polygon_b] and returns an array of clipped polygons. This performs [constant OPERATION_DIFFERENCE] between polygons. Returns an empty array if [param polygon_b] completely overlaps [param polygon_a].
				If [param polygon_b] is enclosed by [param polygon_a], returns an outer polygon (boundary) and inner polygon (hole) which could be distinguished by calling [method is_polygon_clockwise].
			</description>
		</method>
		<method name="clip_polyline_with_polygon">
			<return type="PackedVector2Array[]" />
			<param index="0" name="polyline" type="PackedVector2Array" />
			<param index="1" name="polygon" type="PackedVector2Array" />
			<description>
				Clips [param polyline] against [param polygon] and returns an array of clipped polylines. This performs [constant OPERATION_DIFFERENCE] between the polyline and the polygon. This operation can be thought of as cutting a line with a closed shape.
			</description>
		</method>
		<method name="convex_hull">
			<return type="PackedVector2Array" />
			<param index="0" name="points" type="PackedVector2Array" />
			<description>
				Given an array of [Vector2]s, returns the convex hull as a list of points in counterclockwise order. The last point is the same as the first one.
			</description>
		</method>
		<method name="decompose_polygon_in_convex">
			<return type="PackedVector2Array[]" />
			<param index="0" name="polygon" type="PackedVector2Array" />
			<description>
				Decomposes the [param polygon] into multiple convex hulls and returns an array of [PackedVector2Array].
			</description>
		</method>
		<method name="exclude_polygons">
			<return type="PackedVector2Array[]" />
			<param index="0" name="polygon_a" type="PackedVector2Array" />
			<param index="1" name="polygon_b" type="PackedVector2Array" />
			<description>
				Mutually excludes common area defined by intersection of [param polygon_a] and [param polygon_b] (see [method intersect_polygons]) and returns an array of excluded polygons. This performs [constant OPERATION_XOR] between polygons. In other words, returns all but common area between polygons.
				The operation may result in an outer polygon (boundary) and inner polygon (hole) produced which could be distinguished by calling [method is_polygon_clockwise].
			</description>
		</method>
		<method name="get_closest_point_to_segment">
			<return type="Vector2" />
			<param index="0" name="point" type="Vector2" />
			<param index="1" name="s1" type="Vector2" />
			<param index="2" name="s2" type="Vector2" />
			<description>
				Returns the 2D point on the 2D segment ([param s1], [param s2]) that is closest to [param point]. The returned point will always be inside the specified segment.
			</description>
		</method>
		<method name="get_closest_point_to_segment_uncapped">
			<return type="Vector2" />
			<param index="0" name="point" type="Vector2" />
			<param index="1" name="s1" type="Vector2" />
			<param index="2" name="s2" type="Vector2" />
			<description>
				Returns the 2D point on the 2D line defined by ([param s1], [param s2]) that is closest to [param point]. The returned point can be inside the segment ([param s1], [param s2]) or outside of it, i.e. somewhere on the line extending from the segment.
			</description>
		</method>
		<method name="get_closest_points_between_segments">
			<return type="PackedVector2Array" />
			<param index="0" name="p1" type="Vector2" />
			<param index="1" name="q1" type="Vector2" />
			<param index="2" name="p2" type="Vector2" />
			<param index="3" name="q2" type="Vector2" />
			<description>
				Given the two 2D segments ([param p1], [param q1]) and ([param p2], [param q2]), finds those two points on the two segments that are closest to each other. Returns a [PackedVector2Array] that contains this point on ([param p1], [param q1]) as well the accompanying point on ([param p2], [param q2]).
			</description>
		</method>
		<method name="intersect_polygons">
			<return type="PackedVector2Array[]" />
			<param index="0" name="polygon_a" type="PackedVector2Array" />
			<param index="1" name="polygon_b" type="PackedVector2Array" />
			<description>
				Intersects [param polygon_a] with [param polygon_b] and returns an array of intersected polygons. This performs [constant OPERATION_INTERSECTION] between polygons. In other words, returns common area shared by polygons. Returns an empty array if no intersection occurs.
				The operation may result in an outer polygon (boundary) and inner polygon (hole) produced which could be distinguished by calling [method is_polygon_clockwise].
			</description>
		</method>
		<method name="intersect_polyline_with_polygon">
			<return type="PackedVector2Array[]" />
			<param index="0" name="polyline" type="PackedVector2Array" />
			<param index="1" name="polygon" type="PackedVector2Array" />
			<description>
				Intersects [param polyline] with [param polygon] and returns an array of intersected polylines. This performs [constant OPERATION_INTERSECTION] between the polyline and the polygon. This operation can be thought of as chopping a line with a closed shape.
			</description>
		</method>
		<method name="is_point_in_circle">
			<return type="bool" />
			<param index="0" name="point" type="Vector2" />
			<param index="1" name="circle_position" type="Vector2" />
			<param index="2" name="circle_radius" type="float" />
			<description>
				Returns [code]true[/code] if [param point] is inside the circle or if it's located exactly [i]on[/i] the circle's boundary, otherwise returns [code]false[/code].
			</description>
		</method>
		<method name="is_point_in_polygon">
			<return type="bool" />
			<param index="0" name="point" type="Vector2" />
			<param index="1" name="polygon" type="PackedVector2Array" />
			<description>
				Returns [code]true[/code] if [param point] is inside [param polygon] or if it's located exactly [i]on[/i] polygon's boundary, otherwise returns [code]false[/code].
			</description>
		</method>
		<method name="is_polygon_clockwise">
			<return type="bool" />
			<param index="0" name="polygon" type="PackedVector2Array" />
			<description>
				Returns [code]true[/code] if [param polygon]'s vertices are ordered in clockwise order, otherwise returns [code]false[/code].
			</description>
		</method>
		<method name="line_intersects_line">
			<return type="Variant" />
			<param index="0" name="from_a" type="Vector2" />
			<param index="1" name="dir_a" type="Vector2" />
			<param index="2" name="from_b" type="Vector2" />
			<param index="3" name="dir_b" type="Vector2" />
			<description>
				Checks if the two lines ([param from_a], [param dir_a]) and ([param from_b], [param dir_b]) intersect. If yes, return the point of intersection as [Vector2]. If no intersection takes place, returns [code]null[/code].
				[b]Note:[/b] The lines are specified using direction vectors, not end points.
			</description>
		</method>
		<method name="make_atlas">
			<return type="Dictionary" />
			<param index="0" name="sizes" type="PackedVector2Array" />
			<description>
				Given an array of [Vector2]s representing tiles, builds an atlas. The returned dictionary has two keys: [code]points[/code] is a [PackedVector2Array] that specifies the positions of each tile, [code]size[/code] contains the overall size of the whole atlas as [Vector2i].
			</description>
		</method>
		<method name="merge_polygons">
			<return type="PackedVector2Array[]" />
			<param index="0" name="polygon_a" type="PackedVector2Array" />
			<param index="1" name="polygon_b" type="PackedVector2Array" />
			<description>
				Merges (combines) [param polygon_a] and [param polygon_b] and returns an array of merged polygons. This performs [constant OPERATION_UNION] between polygons.
				The operation may result in an outer polygon (boundary) and multiple inner polygons (holes) produced which could be distinguished by calling [method is_polygon_clockwise].
			</description>
		</method>
		<method name="offset_polygon">
			<return type="PackedVector2Array[]" />
			<param index="0" name="polygon" type="PackedVector2Array" />
			<param index="1" name="delta" type="float" />
			<param index="2" name="join_type" type="int" enum="Geometry2D.PolyJoinType" default="0" />
			<description>
				Inflates or deflates [param polygon] by [param delta] units (pixels). If [param delta] is positive, makes the polygon grow outward. If [param delta] is negative, shrinks the polygon inward. Returns an array of polygons because inflating/deflating may result in multiple discrete polygons. Returns an empty array if [param delta] is negative and the absolute value of it approximately exceeds the minimum bounding rectangle dimensions of the polygon.
				Each polygon's vertices will be rounded as determined by [param join_type], see [enum PolyJoinType].
				The operation may result in an outer polygon (boundary) and inner polygon (hole) produced which could be distinguished by calling [method is_polygon_clockwise].
				[b]Note:[/b] To translate the polygon's vertices specifically, multiply them to a [Transform2D]:
				[codeblocks]
				[gdscript]
				var polygon = PackedVector2Array([Vector2(0, 0), Vector2(100, 0), Vector2(100, 100), Vector2(0, 100)])
				var offset = Vector2(50, 50)
				polygon = Transform2D(0, offset) * polygon
				print(polygon) # prints [(50, 50), (150, 50), (150, 150), (50, 150)]
				[/gdscript]
				[csharp]
				var polygon = new Vector2[] { new Vector2(0, 0), new Vector2(100, 0), new Vector2(100, 100), new Vector2(0, 100) };
				var offset = new Vector2(50, 50);
				polygon = new Transform2D(0, offset) * polygon;
				GD.Print((Variant)polygon); // prints [(50, 50), (150, 50), (150, 150), (50, 150)]
				[/csharp]
				[/codeblocks]
			</description>
		</method>
		<method name="offset_polyline">
			<return type="PackedVector2Array[]" />
			<param index="0" name="polyline" type="PackedVector2Array" />
			<param index="1" name="delta" type="float" />
			<param index="2" name="join_type" type="int" enum="Geometry2D.PolyJoinType" default="0" />
			<param index="3" name="end_type" type="int" enum="Geometry2D.PolyEndType" default="3" />
			<description>
				Inflates or deflates [param polyline] by [param delta] units (pixels), producing polygons. If [param delta] is positive, makes the polyline grow outward. Returns an array of polygons because inflating/deflating may result in multiple discrete polygons. If [param delta] is negative, returns an empty array.
				Each polygon's vertices will be rounded as determined by [param join_type], see [enum PolyJoinType].
				Each polygon's endpoints will be rounded as determined by [param end_type], see [enum PolyEndType].
				The operation may result in an outer polygon (boundary) and inner polygon (hole) produced which could be distinguished by calling [method is_polygon_clockwise].
			</description>
		</method>
		<method name="point_is_inside_triangle" qualifiers="const">
			<return type="bool" />
			<param index="0" name="point" type="Vector2" />
			<param index="1" name="a" type="Vector2" />
			<param index="2" name="b" type="Vector2" />
			<param index="3" name="c" type="Vector2" />
			<description>
				Returns if [param point] is inside the triangle specified by [param a], [param b] and [param c].
			</description>
		</method>
		<method name="segment_intersects_circle">
			<return type="float" />
			<param index="0" name="segment_from" type="Vector2" />
			<param index="1" name="segment_to" type="Vector2" />
			<param index="2" name="circle_position" type="Vector2" />
			<param index="3" name="circle_radius" type="float" />
			<description>
				Given the 2D segment ([param segment_from], [param segment_to]), returns the position on the segment (as a number between 0 and 1) at which the segment hits the circle that is located at position [param circle_position] and has radius [param circle_radius]. If the segment does not intersect the circle, -1 is returned (this is also the case if the line extending the segment would intersect the circle, but the segment does not).
			</description>
		</method>
		<method name="segment_intersects_segment">
			<return type="Variant" />
			<param index="0" name="from_a" type="Vector2" />
			<param index="1" name="to_a" type="Vector2" />
			<param index="2" name="from_b" type="Vector2" />
			<param index="3" name="to_b" type="Vector2" />
			<description>
				Checks if the two segments ([param from_a], [param to_a]) and ([param from_b], [param to_b]) intersect. If yes, return the point of intersection as [Vector2]. If no intersection takes place, returns [code]null[/code].
			</description>
		</method>
		<method name="tessellate_curve_in_rect">
			<return type="PackedVector2Array" />
			<param index="0" name="points" type="PackedVector2Array" />
			<param index="1" name="types" type="PackedByteArray" />
			<param index="2" name="transform" type="Transform2D" />
			<param index="3" name="limit" type="Rect2" />
			<param index="4" name="use_order5" type="bool" default="false" />
			<description>
				Returns a polyline that approximates the curve described by [param points] and [param types]. The precision of the approximation is determined by `[param transform]` and `[param limit]`.
				The first point in [param points] is the starting point of the curve. The remaining points are interpreted according to [param types]. [param types] is interpreted as a string of bits, with each byte being interpreted as eight bits from least significant to most significant. A value of [code]0[/code] indicates the next segment is a bezier segment. If [param use_order5] is [code]false[/code] then it is a cubic bezier. The next two points in [param points] are interpreted as control points, and the third is interpreted the end point. If [param use_order5] is [code]false[/code] then it is an order 5 bezier. The next four points in [param points] are interpreted as control points, and the fifth is interpreted the end point. Order 5 beziers can be more complex, but allow producing a continuous curvature.
				If the next bit represented by [param types] is [code]1[/code], the next four points in [param points] are interpreted as an elliptic arc segment. The ellipse is centered along the second point, and intersects the first and third points. The angle range of the arc is determined by the fourth point and the previous point on the curve. If the points do not coincide with the ellipse, line segments connecting the points to the ellipse are added. The arc's drawing direction is determined by the first and third points. If they are clockwise relative to the second point, the arc is drawn clockwise, otherwise it is drawn counter-clockwise.
				If [param types] does not contain enough bits to interpret all the points in [param points], it is padded with [code]0[/code] bits as necessary. If it contains too many bits, it is truncated.
				The precision of the approximation is determined as following: For a curve [code]C[/code], let [code]T(x)[/code] be the curve that results from multiplying every point in [code]x[/code] with the transformation [param transform]. Let [code]W(x, y)[/code] be the winding number for the closed curve [code]x[/code] around the point [code]y[/code], i.e. the number of clockwise rotations the curve completes around the point, minus the number of counter-clockwise rotations. Let [code]curve[/code] be the closed curve formed by connecting the ends of the curve described by [param points] and [param types]. Let [code]P[/code] be the polygon represented by connecting the returned points in a cycle. For every point [code]x[/code] inside [param limit], there exists a point [code]y[/code] so that [code]W(T(C), x)=W(T(P), y)[/code] and the distance between [code]x[/code] and [code]y[/code] is less than [code]0.5[/code].
				[b]Note:[/b] The transformed output polygon is [i]not[/i] clipped to [param limit]. For any point [code]x[/code] outside the bounding rectangle of [code]T(S)[/code], [code]W(T(P), x)=0[/code] For any other point [code]x[/code] outside [param limit] [code]W(T(P), x)[/code] is [i]undefined[/i], and can be [i]any[/i] value. To avoid any undefined areas, use a [param limit] that contains the entire transformed curve.
				[b]Note:[/b] The output is [i]not[/i] transformed by [param transform]. It is only used to determine the precision.
				This function will try to minimize the number of points returned, while maintaining the above precision conditions.
			</description>
		</method>
		<method name="triangulate_delaunay">
			<return type="PackedInt32Array" />
			<param index="0" name="points" type="PackedVector2Array" />
			<description>
				Triangulates the area specified by discrete set of [param points] such that no point is inside the circumcircle of any resulting triangle. Returns a [PackedInt32Array] where each triangle consists of three consecutive point indices into [param points] (i.e. the returned array will have [code]n * 3[/code] elements, with [code]n[/code] being the number of found triangles). If the triangulation did not succeed, an empty [PackedInt32Array] is returned.
			</description>
		</method>
		<method name="triangulate_polygon">
			<return type="PackedInt32Array" />
			<param index="0" name="polygon" type="PackedVector2Array" />
			<description>
				Triangulates the polygon specified by the points in [param polygon]. Returns a [PackedInt32Array] where each triangle consists of three consecutive point indices into [param polygon] (i.e. the returned array will have [code]n * 3[/code] elements, with [code]n[/code] being the number of found triangles). Output triangles will always be counter clockwise, and the contour will be flipped if it's clockwise. If the triangulation did not succeed, an empty [PackedInt32Array] is returned.
			</description>
		</method>
		<method name="triangulate_polygons">
			<return type="Dictionary" />
			<param index="0" name="polygons" type="PackedVector2Array[]" />
			<param index="1" name="winding_even_odd" type="bool" />
			<description>
				Triangulates the polygons specified in [param polygons]. Each [PackedVector2Array] is interpreted as a single closed polygon. Concave polygons, overlapping polygons, and self-intersections are fully supported. The returned dictionary has two keys: [code]vertices[/code] is a [PackedVector2Array] containing vertices used in the triangulation. This includes the original vertices from [param polygons], intersection points, and points added to deal with concave areas. [code]indices[/code] is a [PackedInt32Array] where each triangle consists of three consecutive point indices into [code]vertices[/code] (i.e. the returned array will have [code]n * 3[/code] elements, with [code]n[/code] being the number of found triangles). Output triangles will always be counter clockwise.
				The way overlapping polygons are handled is determined by [param winding_even_odd]. If [code]true[/code] every edge separates a filled and unfilled area. If [code]false[/code] overlapping areas are kept if their surrounding polygons are the same direction clockwise or counter clockwise, and subtracted if they are opposite directions.
			</description>
		</method>
	</methods>
	<constants>
		<constant name="OPERATION_UNION" value="0" enum="PolyBooleanOperation">
			Create regions where either subject or clip polygons (or both) are filled.
		</constant>
		<constant name="OPERATION_DIFFERENCE" value="1" enum="PolyBooleanOperation">
			Create regions where subject polygons are filled except where clip polygons are filled.
		</constant>
		<constant name="OPERATION_INTERSECTION" value="2" enum="PolyBooleanOperation">
			Create regions where both subject and clip polygons are filled.
		</constant>
		<constant name="OPERATION_XOR" value="3" enum="PolyBooleanOperation">
			Create regions where either subject or clip polygons are filled but not where both are filled.
		</constant>
		<constant name="JOIN_SQUARE" value="0" enum="PolyJoinType">
			Squaring is applied uniformally at all convex edge joins at [code]1 * delta[/code].
		</constant>
		<constant name="JOIN_ROUND" value="1" enum="PolyJoinType">
			While flattened paths can never perfectly trace an arc, they are approximated by a series of arc chords.
		</constant>
		<constant name="JOIN_MITER" value="2" enum="PolyJoinType">
			There's a necessary limit to mitered joins since offsetting edges that join at very acute angles will produce excessively long and narrow "spikes". For any given edge join, when miter offsetting would exceed that maximum distance, "square" joining is applied.
		</constant>
		<constant name="END_POLYGON" value="0" enum="PolyEndType">
			Endpoints are joined using the [enum PolyJoinType] value and the path filled as a polygon.
		</constant>
		<constant name="END_JOINED" value="1" enum="PolyEndType">
			Endpoints are joined using the [enum PolyJoinType] value and the path filled as a polyline.
		</constant>
		<constant name="END_BUTT" value="2" enum="PolyEndType">
			Endpoints are squared off with no extension.
		</constant>
		<constant name="END_SQUARE" value="3" enum="PolyEndType">
			Endpoints are squared off and extended by [code]delta[/code] units.
		</constant>
		<constant name="END_ROUND" value="4" enum="PolyEndType">
			Endpoints are rounded off and extended by [code]delta[/code] units.
		</constant>
	</constants>
</class>
